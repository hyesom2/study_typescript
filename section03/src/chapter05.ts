/* 
  * 타입 추론
  - TS는 점진적인 타입 시스템 : TS는 자동으로 변수의 타입을 추론
  - 타입 추론을 잘 이용하면 굳이 타입을 일일이 변수에 정의하지 않아도 됨
  → 타이핑 할 양이 줄어듦
  → 코드가 간결해짐
  → 생산성 올라감
  → 주의점) TS라도 해도 모든 상황에서 타입을 추론해 주지 않음 - ②
*/
// - 변수를 선언할 때 변수를 정의할 수 있는 이런 문법을 제공해서 프로그램이 실행되기 전에 타입 검사를 수행하지만, 만약에 변수타입이 정의되지 않을 때에도 그냥 변수를 선언하고 초기값을 넣어주기만 하면 알아서 타입스크립트가 초기값을 기준으로 변수의 타입을 추론한다.
// - 결론) TS는 자동으로 변수의 타입을 추론
let a = 10;
// ② - 주의점) 함수의 메개변수를 선언할 때엔 매개변수의 type을 직접 정의해주어야 한다.
// function func(param) { } error

// 타입 추론이 가능한 상황_1) 일반적인 변수를 선언하는 상황 : TS가 추론하는 기준은 "변수의 초기값"
let b = 10; // number 타입으로 추론
let c = "hello"; // string 타입으로 추론
let d = {
  id: 1,
  name: '유저1',
  url: ["1", "2"]
}
// 객체를 구조분해 할 때에도 커서를 올리면 변수의 타입을 자동으로 추론 가능
let { id, name, url } = d;
// 배열을 구조분해 할당해도 각각의 원소는 타입이 잘 추론된다.
let [one, two, three] = [1, "hello", true];
// 함수의 경우 반환값 타입도 추론 가능, 반환값을 추론할 땐 초기화 하는 값이 아닌 return문 다음의 반환값을 기준으로 추론
// 매개변수가 있을 경우, 기본값이 설정된 매개변수의 타입도 "기본값을 기준"으로 타입을 추론 
function func(message = "TypeScript!") {
  return "hello";
}

// 타입 추론이 가능한 상황_2) 변수를 선언하지만 초기값을 생략한 상황 : any타입으로 추론되기 때문에 아무값이나 넣을 수 있음 → any타입의 진화
let e;
e = 10;
// e에 10을 넣어줌으로써 e의 타입은 number가 된다.
e.toFixed(); // number 관련 메서드 사용O
// e.toUpperCase(); // error, string 관련 메서드 사용X

e = "hello";
// e에 "hello"를 넣어줌으로써 e의 타입은 string이 된다.
e.toUpperCase(); // string 관련 메서드 사용O
// e.toFixed(); // error, number 관련 메서드 사용X

// 타입 추론이 가능한 상황_3) const로 변수를 선언했을 경우 : 값을 갖는 number literal타입으로 추론 → let의 경우 number타입으로 추론
const f = 10; // const로 선언한 f라는 변수는 상수이기 때문에 10이라는 값 이외에는 다른 값을 담을 수 없다.
const g = "hello";
let arr = [1, "string"]; // string와 number의 유니온타입

