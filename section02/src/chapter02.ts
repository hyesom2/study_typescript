// 배열
// 예) numArr 변수를 만들고 이 변수의 초기값으로 3개의 숫자를 담는 배열을 만듦
// 1. 숫자를 담는 배열
let numArr: number[] = [1, 2, 3];

// 2. 문자열을 담는 배열
let strArr: string[] = ["a", "b", "c"];

// 3. 불리언값을 담는 배열
// let boolArr: boolean[] = [true, false];
// 3-1. Generic 문법 : TS에서 Array< 다른타입 >
let boolArr: Array<boolean> = [true, false];

// 예) 배열에 들어가는 요소들의 타입이 다양한 경우
// Tip) TS에서 어떻게 정의를 해야할 지 잘 모르겠을 때 → 마우스를 변수 위에 올려보자
// 4. 소괄호(요소의 타입) + 대괄호(배열) → (number | string) : 배열의 요소가 number타입이거나 string타입 일 수 있다. → Union타입
let multiArr: (number | string)[] = [1, 'hello'];

// 5. 다차원 배열의 타입을 정의하는 방법 → 2차원 또는 3차원 배열
// 예) number타입의 값들을 저장하는 2차원 배열
let doubleArr: number[][] = [
  [1, 2, 3],
  [4, 5]
];

/*
  ※ 튜플
  → JS에는 없고, TS에서 특별히 제공 되는 타입
  → 길이와 타입이 고정된 배열
  → JS 배열의 경우, 기본적으로 길이와 타입 둘 다 고정이 안되어 있음 → 갯수를 마음대로 늘릴 수 있고 배열에 들어가는 요소의 타입도 자유로움
  → TS 배열의 경우, 배열에 들어가는 요소의 타입은 고정시킬 수 있지만 길이까지는 고정시킬 수 없음 (타입만 맞으면 계속 길이가 늘어남)
  → but, 튜플은 타입도 고정되고, 길이까지도 고정할 수 있는 배열타입
*/
// 예) tup1 변수의 타입을 number타입의 배열이 아닌 number타입의 값을 저장하고 길이가 2인 튜플 타입으로 정의
let tup1: [number, number] = [1, 2];
// number타입이지만 길이를 만족하지 않으면 오류가 발생
// tup1 = [1, 2, 3];
// 길이는 만족하지만 타입을 만족하지 않는 배열도 오류가 발생
// tup1 = ["1", "2"];

// 예) 3개의 타입을 저장하는 배열
// tup2는 길이가 3이고 첫번째 number, 두번째 string, 세번째 boolean타입인 튜플
let tup2: [number, string, boolean] = [1, "2", true];
// 순서를 바꾸면 오류가 발생
// let tup2: [number, string, boolean] = [1, true, "2"];
// 길이가 다르면 오류가 발생→
// let tup2: [number, string, boolean] = [1, "2"];

/*
  * tuple은 별도로 존재하는 자료형이 아니다.
  → 그냥 배열 이다.
  → tsc로 컴파일 후 js파일 확인
  → 배열이기 떄문에 push(), pop() 메서드 사용 가능
*/
// tup1.push(1);
// tup1.pop();
// tup2.pop();
/* 
  * tup1, tup2 변수에 튜플 타입을 정의할 때 길이2개 까지만 들어가도록 설정을 했는데, 왜 오류가 안날까?
  → 배열 메서드를 사용할 때는 튜플의 길이 제한이 발동하지 않는다.
  → JS의 배열이라고 생각하기 때문에 알아보지 못하는 것
  → 튜플 타입을 사용할 땐 배열 메서드를 사용해서 push(), pop()같은 요소를 추가하거나 제거하는 기능을 사용할 땐 주의하자.
*/

/*
  * 튜플을 유용하게 사용할 수 있는 상황
  예) users라는 유저 정보를 저장하는 2차원 배열을 만들 때,
  유저4까지 배열의 규칙을 잘 정리해서 만들었는데, 다른 사람이 유저5를 만들 때 id와 유저이름의 순서를 바꿔버림
  → 배열을 사용할 때 index별로 다른 값을 넣어야 할 때 index의 순서와 위치가 헷갈릴 때
  → 튜플을 사용하면 배열을 사용할 때, index의 위치에 따라서 넣어야 되는 값들이 이미 정해져 있고, 그 순서를 지키는게 중요할 때
*/
const users: [string, number][] = [
  ["유저1", 1],
  ["유저2", 2],
  ["유저3", 3],
  ["유저4", 4],
  // [5, "유저5"],
]
